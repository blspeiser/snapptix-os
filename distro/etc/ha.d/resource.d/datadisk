#!/bin/bash
#
# chkconfig: 345 70 8
# description: Loads and unloads the drbd module
#
# complete rewrite from scratch by Lars Ellenberg <l.g.e@web.de> in June 2002
# for the drbd project
# released under the same terms as drbd itself,
# or the GPL, whatever suits you best.
#
# for questions wrt the functionality search for QQQ in the comments below
# for style issues see end of file
#
### BEGIN INIT INFO
# Provides: drbd
# Required-Start: $network $syslog
# Required-Stop:
# Default-Start:  3 5
# Default-Stop:   0 1 2 6
# Description:    Control drbd resources.
### END INIT INFO
#
# QQQ Required-Start: $sshd
#
# QQQ Provides: datadisk ?
#
# QQQ should there be an auto background mode as to
#     not block other init scripts?
# AAA It is there!
#	  see skip-wait, and if needed, (-)inittimeout
#     or load-only
#
# Q   I get spurious "synchronization finished" messages
# A   No problem. If the nodes find each other very quickly,
#     and there is no need for synchronization, it may well
#     happen, that these "do nothing" childs get "reaped".
#     Thus the message.
#
# Q   Will you please clean up this ugly signal passing code?
# A   Sure. Eventually. I do not like it either, but it seems
#     to work most of the time ;)
#     In drbd 0.7 we will hopefully have more straight forward
#     resource scripts.
#
# functionality translated from drbd.pl CVS 1.5 to
# BASH_VERSINFO=(2 05 0 1 release i386-suse-linux)
# should now work with
# BASH_VERSINFO=(2 02 1 1 release i686-pc-linux-gnu)
# and better, too
# !! 2.05b has changed wait builtin semantics, at least for me.
# !! wait now is interupted by signals.
# altered some small things, it should does now work again with
# BASH_VERSINFO=(2 05b 0 1 release i586-suse-linux)
#
# parser is more permissive wrt whitespace
# easily extended for new options or more than two partners
#
# shouldn't there be more descriptive comments? ;)
#
CVSID='$Id: drbd,v 1.35 2003/03/23 15:26:37 kde Exp $'
CONTACT='Lars Ellenberg <l.g.e@web.de>, drbd-devel@lists.sourceforge.net'
#

# Environment and shell options
###########################

	# If I was confident enough, I would use set -e for the whole script
	# so each failed simple command would fail the script.
	# I had to use error checks on all simple commands ...
	# for now only set this for the startup section, so I can give less
	# missleading error messages

	trap "echo Error during script startup. This may be an incompatible bash version" EXIT
	set -e

if ! [ "${BASH_VERSINFO[0]}" -ge 2 -a "${BASH_VERSINFO[1]//[^0-9]/}" -ge 2 ] ; then
	echo "bash version is older than known to work."
	echo "  If it works despite of that, report as known good version to"
	echo "  $CONTACT"
	echo "  so this value can be adjusted in the script."
	echo "  Otherwise: please upgrade to a newer bash version. -- Thanks"
fi

	set -o noglob            # disable expansion of *? [] etc
	set -o noclobber         # don't overwrite files with '>' redirection

	shopt -s extglob         # enable extended pattern matching features
	shopt -s expand_aliases  # enable aliases

	# test compatibility early
	try1=try2
	try2="something"
	if [ ${!try1} != "something" ] ; then
		 echo "Indirection operator not implemented."
		 echo "This script will not work with this version of bash."
		 exit -1
	fi
	unset try1 try2
	case yes713 in
	@(no|yes)+([0-9])) ;;
	*)
		 echo "Extended pattern matching does not work."
		 echo "This script will not work with this version of bash."
		 exit -1
		 ;;
	esac
	# [[ dummy ]] # will fail the script if not implemented due to set -e above
	# (( 1 ))     # dito

	IFS=$' \t\n' # just in case

	PATH=/sbin:/usr/sbin:/bin:/usr/bin

	base=${0##*/}
	link=${base#*[SK][0-9][0-9]}
	link=${link%.sh}
	link=${link#rc}

	HOSTNAME=$(hostname -s)

	# since the location is not guaranteed to be the same on all distibutions,
	# do not use full path
	MODPROBE="modprobe"
	RMMOD="rmmod"
	UMOUNT="umount -v"
	MOUNT="mount -v"
	FUSER="fuser"
	TOUCH="touch"

	DRBD_SETUP="drbdsetup"
	PROC_DRBD="/proc/drbd"
	CONFIG="/etc/drbd.conf"
	CONFIG_PARSED="/var/lib/drbd/drbd.conf.parsed"

	PING="ping -c 1 -w 3"
	# do we have [-w deadline] option?
	$PING localhost &> /dev/null || {
		[ $? -eq 2 ] && PING="timeout_exec -3 ping -c 1"
	}

	: ${VERBOSITY:=-1}

	# QQQ thought this could be useful
	# TERMINAL=/dev/tty
	# maybe we can use $CONSOLE, which should be exported by init anyways?
	#
	for TERMINAL in /proc/self/fd/0 /dev/tty /dev/tty2 ""
	do
	   [ -z "$TERMINAL" ] && break
	   ( [ -t 1 ] < $TERMINAL &> $TERMINAL ) 2>/dev/null && break
	done
	if [ -z "$TERMINAL" ] ; then
		echo "$link: FATAL: no terminal"
		exit -1
	fi


# frame work for commandline options
	# I use getopt, if it is in PATH. if getopt is not found, it will
	# (hopefully) silently work anyways, though the user has to supply correct
	# ordering and may not abbreviate
	OPTIONS='dry-run,info,parse,dummy,config:'
	GETOPT="`type -p getopt` -s bash -n $link -a -l $OPTIONS -- . " \
	|| GETOPT="printf '%q '"


# "compatibility" functions for bash versions wich do not know yet about
# [[ ]], (( )) and the like
###########################
# def: mymatch

	# mymatch <something> <pattern>
	# returns vie $? 0 for true, -1 for false.
	# replaces [[ something == pattern ]]
	function mymatch
	{
		case "$1" in $2) return 0;; *) return -1;; esac
	}


# Configuration Template
###########################

	# defines a /complete/ CONF structure
	#
	# first word of template value:
	#   __optional__   : empty default values , not used right now
	#   __required__   : required values
	#   {yes,no}       : toggles
	#   __appended__   : values to be concatenated
	#   __implicit__   : implicitly defined through internal data
	#                  : or by use of __appended__
	#   any other value: default value if not mentioned in config file
	#           !!!    : may NOT contain whitespace
	#
	# second to last word of template value are interpreted as extended bash
	# pattern, which the actual TOKEN_LINE must match.
	# special patterns are -x and -b, which test for executable, or
	# block device, respectively
	#
	# if an option appears without explicit = in the config file, and
	#    default is *not* {yes,no}
	#         -> Parse error
	#    default *is* {yes,no}
	#         -> assigned the "not default" value
	#         this makes probably only sense with boolean toggles
	#         like skip-wait
	#
	# if something is in the CONF file but not listed here it is
	# treated as error
	#
	# "HOST_*" is special:
	# it is replaced by the actual section hostname

declare -a TEMPLATE
	TEMPLATE=( \
		__hash__NNN                                                           \
		                                                                      \
		skip-wait        "no    skip-wait?(=@(yes|no|true|false|1|0|on|off))" \
		load-only        "no    load-only?(=@(yes|no|true|false|1|0|on|off))" \
		inittimeout      "0                *=?(-)+([0-9])          "          \
		protocol         "__required__     *=@(a|A|b|B|c|C)        "          \
		fsckcmd          "__required__     -x                      "          \
		incon-degr-cmd   "0                -x                      "          \
		                                                                      \
		disk              __implicit__                                        \
		disk:disk-size   "__appended__     +([^ ])=+([0-9])?([kMG])"          \
		disk:do-panic    "__appended__     do-panic                "          \
		                                                                      \
		net               __implicit__                                        \
		net:connect-int  "__appended__     +([^ ])=+([0-9])        "          \
		net:ping-int     "__appended__     +([^ ])=+([0-9])        "          \
		net:skip-sync    "__appended__     skip-sync               "          \
		net:sync-rate    "__appended__     +([^ ])=+([0-9])?([kMG])"          \
		net:sync-min     "__appended__     +([^ ])=+([0-9])?([kMG])"          \
		net:sync-max     "__appended__     +([^ ])=+([0-9])?([kMG])"          \
		net:sync-nice    "__appended__     +([^ ])=+([0-9\+\-])    "          \
		net:timeout      "__appended__     +([^ ])=+([0-9])        "          \
		net:tl-size      "__appended__     +([^ ])=+([0-9])        "          \
		                                                                      \
		HOSTS             __implicit__                                        \
		                                                                      \
		HOST_device      "__required__     *=/dev/nb*              "          \
		HOST_disk        "__required__     -b                      "          \
		HOST_port        "__required__     *=+([0-9])              "          \
		HOST_address     "__required__     *=+([_A-Za-z0-9.-])"               \
	)
		# QQQ restrict this to ip addresses in dotted quad notation.
		# otherwise the sanity check below would not be reliable.
		# HOST_address  "__required__     *=+([0-9])\.+([0-9])\.+([0-9])\.+([0-9])"
	TEMPLATE="__hash__${#TEMPLATE[*]}"
	readonly TEMPLATE

# this will store the parsed configuration data
CONF=(__hash__0)

# Convenience Functions and Aliases
###########################
# def: print_usage_and_exit debug reset_lineno die_at

	# work around a bug in bash's LINENO
	# MIND YOU! you have to include die's in braces, if you use it like
	# do something || { die errtxt; }
	alias die='reset_lineno; die_at "$0" "$FUNCNAME" "$LINENO"'
	alias trace='debug 3 "%-50s # %s" "$FUNCNAME($*)"'
	alias trace4='debug 4 "%-50s # %s" "$FUNCNAME($*)"'
	alias trace0='debug 0 "%-50s # %s" "$FUNCNAME($*)"'

	function print_usage_and_exit
	{
		case $link in

		datadisk)
			echo -e "\nUSAGE: datadisk [resource] start|stop|status"
			;;

		drbd)
			echo -e "\nUSAGE: drbd [resource] start|stop|status|reconnect|checkconfig"
			;;

			*)        cat <<-___
				Don't know what to do.
				I expect to be called with a script name of either datadisk or drbd.
				USAGE:
				drbd     [resource] start|stop|status|reconnect|checkconfig
				datadisk [resource] start|stop|status
				___
		esac
		OPTIONS=${OPTIONS//:/=arg}
		echo -e "OPTIONS: --${OPTIONS//,/ --}\n"
		exit 255
	}

	# printf > stderr
	function debug
	{
		[ "$1" -le "$VERBOSITY" ] || return 0
		local lev=$1 tmp=$2 ; shift 2
		printf "<$lev> $tmp\n" "$@" >&2
	}

	MAGIC_LINENO=$(( LINENO + 2 ))
	function reset_lineno
	{
		# "this is a dirty hack!"
		return 0
	}

	# die
	# I like the perl way of saying "do_it or die"
	#
	# FIXME
	# BASH_VERSINFO=(2 05 0 1 release i386-suse-linux)
	# (maybe this is fixed in some later bash version?)
	#
	# bash seems to have a bug regarding the internal variable LINENO
	# it does not work in functions which call other functions.
	# my workaround is the call to reset_lineno in the alias above,
	# and add the known lineno of that function to the value here.
	#
	function die_at
	{
		set +e
		local FILE=$1 FUNC=$2 LINE=$3 i
		shift 3

		# set some default message.
		[ -z "$*" ] && set -- "Died."

		# we are still reading the config?
		if [ -n "$CONFIG" ] ; then
			echo -e "\n  last token read from <$CONFIG> was"
			printf "%4i: %s%s\n%6s" "${TOKEN_LINE_NR:-0}" "$TOKEN" "$TOKEN_LINE" ""
			let i=0; while [ $i -lt ${#TOKEN} ] ; do let i=i+1; printf "^"; done
		fi

		# echo the message, i.e. the positional parameters.
		# should I use printf functionality?
		echo -e "\n$link: $*"

		# if we are in a function, append it to FILE
		# otherwise set MAGIC_LINENO to zero, since we are on the script level
		# and LINENO is valid.
		[ -n "$FUNC" ] && FILE="$FILE ($FUNC)" || MAGIC_LINENO=0
		case "$*" in
		*$'\n')  :;;
		*)
			cat <<-___

			  stopped at $FILE line $(( LINE + MAGIC_LINENO )).

			  CVSID ${CVSID//\$/}
			  BASH_VERSINFO (${BASH_VERSINFO[*]})

			  If you feel this script is buggy, please report to
			  $CONTACT

			___
		esac
		# if it is a terminal, beep
		# [ -t 1 ] && printf "\a"
		exit 255
	}

# "hash" emulation functions
###########################
# def: store fetch Dump
# not yet: delete
# "fetch" can be used like "exists"

	# QQQ
	# these "bash hashes" are kind of "proof of concept" only.
	#
	# all this could be done with variable indirection,
	# and for many devices be much faster that way.
	# I would need to map all non-identifier key names
	# to underscore, then store would be
	#   eval "${h}_${k//[^a-zA-Z0-9_]/_}=\$v"
	# and fetch
	#   x=${h}_${k//[^a-zA-Z0-9_]/_}; RET_VAL=(${!x})
	# 
	# should I rewrite this part?
	#

	# store [-new|-append] <Name> <Key> <Value>
		# stores <Key> and <Value> in shell array <Name> on odd and even
		# indices, respectively. If <Key> is already set, <Value> is
		# reset, unless modifiers are given:
		#	-new    : dies if <Key> already existed
		#	-append : appends <Value> to the old Value
		#	remember to include a separator, if you need one!
		# return vale is always 0 ( dies on error )
		# RET_VAL:
		# -- falls through from fetch --
		#	[0] = _old_ Value
		#	[1] = index position of <Value> in shell array <Name>
		#	[2] = number of <Key> <Value> pairs in the "hash"
		#
		# bash has arrays, not hashes, so since this loops over all
		# elements of the array, it will soon get slow
		#
	function store
	{
		trace
		RET_VAL=()
		local must_be_new="no" is_new="no" append="no"
		# modifier given?
		while mymatch "$1" "-*"; do
			case $1 in
			-new)
				must_be_new="yes" ;;
			-append)
				append="yes" ;;
			*)
				die "unknown modifier $1" ;;
			esac
			shift
		done

		local h=$1 k=$2 v=$3

		fetch "$h" "$k" || is_new="yes"
		local o=${RET_VAL[0]} i=${RET_VAL[1]} n=${RET_VAL[2]}

		if [ $is_new == yes ]; then
			eval "$h[$((i - 1))]='$k'"
			eval "$h[0]=__hash__$((n + 2))"
		else
			[ $must_be_new == yes ] \
			&& { die "$PARSE: $k already set"; }
		fi

		if [ $append == yes ] ; then
			eval "$h[$i]='$o$v'"
		else
			eval "$h[$i]='$v'"
		fi
	}

	# fetch <Name> <Key>
		# fetches <Value> for <Key> in shell array <Name>
		# can also be used to test for existence of <Key>
		#
		# loops over the odd indices, if one matches <Key>, the
		# corresponding even index <Value> is returned.
		#
		# RET_VAL:
		#	[0] = Value
		#	[1] = index position of <Value> in shell array <Name>
		#	[2] = number <Key> <Value> elements in the "hash" array
		#
		# return value is 0 if <Key> was found, and
		# otherwise 1
		#
		# in the latter case, [1] points to the next free indices if
		# <Key> was not found (so [1] is greater than [2])
		#
		# bash has arrays, not hashes, so since this loops over all
		# elements of the array, it will soon get slow
		#
	function fetch
	{
		trace4
		RET_VAL=()
		local h=$1 k=$2 i
		# did you know the reference indirection operator?
		local n=${!h}
		case $n in
			"" )
				eval "$h=(__hash__0)"; n=0 ;;

			__hash__+([0-9]) )
				n=${n#__hash__} ;;

			* )
				die "$h is not a valid hash" ;;
		esac
		eval "set -- \"\${$h[@]}\""
		shift
		let i=1; while [ $i -lt $# ] ; do
			[ "${!i}" == "$k" ] && break
			let i=i+2
		done
		let i=i+1
		RET_VAL=("${!i}" $i $n)
		debug 4 "$FUNCNAME returns (%s)" "${RET_VAL[*]}"
		return $(( i > n ))
	}

	# Dump <Name>
		# pretty prints content of "hash" <Name>
		# in a bash source-able form
		#
	function Dump
	{
		trace
		RET_VAL=()
		local h=$1 i
		local n=${!h}
		case $n in
			__hash__+([0-9]) )
				 n=${n#__hash__} ;;

			* )  die "$h is not a valid hash" ;;
		esac
		# could use the %q (quote) extension to printf,
		# but it looks too ugly
		# quote single quotes
		eval "set -- \"\${$h[@]//\'/\'\\\'\'}\""
		echo "$h=(\\"
		echo -e "\t$1 \\"
		let i=2; while [ $i -lt $# ] ; do
			printf "  %-30s" "'${!i}'"; let i=i+1
			echo " '${!i}' \\" ; let i=i+1
		done
		echo ")"
	}


# Parser
###########################
# def: get_token expect skip_section check_token_type
# def: parse_option_section parse_host_section
# def: parse_resource_section parse_config read_parsed_config
# def: check_one_parameter check_if_all_parameters_set

	# if line contains "=" token is line (leading and trailing whitespace removed)
	# otherwise token is consecutive non-whitespace
	# you may include as many whitespace as you like
	# you may separate the "=" sign by whitespace

	function get_token
	{
		# not local, but owned by parse_config
		TOKEN=''
		TOKEN_LINE=${TOKEN_LINE##+([$IFS])}
		until [ -n "$TOKEN_LINE" ] ; do
			read TOKEN_LINE || return 1
			let TOKEN_LINE_NR=TOKEN_LINE_NR+1
			debug 4 "- $CONFIG %4d: '$TOKEN_LINE'" $TOKEN_LINE_NR
			# strip comments. a "#" within a word is *not* considered comment
			# leader, it *has* to follow a whitespace or be the first character
			TOKEN_LINE=${TOKEN_LINE%%@(+([$IFS])|)#*}
		done
		case "$TOKEN_LINE" in
			*=*)
				# remove whitespace surrounding first equal sign
				TOKEN=${TOKEN_LINE/*([$IFS])=*([$IFS])/=}
				TOKEN_LINE=''
				;;
			*)
				TOKEN=${TOKEN_LINE%% *}
				TOKEN_LINE=${TOKEN_LINE#$TOKEN}
				;;
		esac
		debug 5 "%s" "- tok: '$TOKEN'" "rem: '$TOKEN_LINE'"
	}

	# assertion: $TOKEN is $1. if not, die.
	# $1 might be a pattern
	function expect
	{
		mymatch "$TOKEN" "$1" && return
		die "$PARSE: expected ($1), got '$TOKEN'"
	}

	function skip_section
	{
		expect "{"
		local -i depth=1
		until [ "$depth" == 0 ] ; do
			get_token || { die "$PARSE: unexpected end of file"; }
			case "$TOKEN" in
				"{") let depth=depth+1;;
				"}") let depth=depth-1;;
			esac
		done
	}

	# expects positional parameters to be the TEMPLATE value of the current TOKEN
	function check_token_type
	{
		case $1 in

		__implicit__*)
			die "$PARSE: unknown option '${TOKEN%%=*}'" ;;

		__required__*)
			local hint=''
			[ -n "$TOKEN_LINE" ] && hint="\n\tdid you forget the = sign?"
			mymatch "$TOKEN" "*=*" || { die "$PARSE: need value for '$TOKEN'.$hint" ; }
			;;

		esac

		shift

		local pattern="$*" ret=0
		debug 5 "check_token_type: $TOKEN , $pattern"

		case $pattern in

		-x)
			pattern="executable"
			set -- ${TOKEN#*=}
			type -p $1 &> /dev/null ; ret=$? ;;

		-b)
			pattern="block device"
			test "$host" = "$HOSTNAME" || return 0
			test -b "${TOKEN#*=}" ; ret=$? ;;

		*)
			mymatch "$TOKEN" "$pattern"; ret=$?
			pattern="'$pattern'" ;;

		esac

		[ "$ret" != 0 ] && { die "bad value '$TOKEN',\n\t$pattern expected"; }
	}

	function parse_option_section
	{
		trace "for $RES"
		local option=$TOKEN key
		PARSE="$PARSE, $option"
		get_token ; expect "{"
		while get_token; do
			[ "$TOKEN" == "}" ] && break
			key=${TOKEN%%=*}
			fetch TEMPLATE "$option:$key"
			mymatch "$RET_VAL" "__appended__*" \
			|| { die "$PARSE: unknown option '$TOKEN'"; }
			check_token_type $RET_VAL
			store -append CONF "$RES:$option" " --$TOKEN"
		done
		[ "$TOKEN" == "}" ] || { die "$PARSE: unexpected end of file"; }
		PARSE=${PARSE%, $option}
	}

	function parse_host_section
	{
		trace "for $RES on $TOKEN"
		local host=$TOKEN
		PARSE="$PARSE, on $host"

		get_token ; expect "{"
		while get_token; do
			[ "$TOKEN" == "}" ] && break
			local key=${TOKEN%%=*}
			local val=${TOKEN##$key?(=)}
			fetch TEMPLATE "HOST_$key" \
			|| { die "$PARSE: unknown option '$key'"; }
			check_token_type $RET_VAL
			store -new CONF "$RES:on $host:$key" "$val"
		done
		[ "$TOKEN" == "}" ] || { die "$PARSE: unexpected end of file"; }
		store -append CONF "$RES:HOSTS" " $host "
		PARSE=${PARSE%, on $host}
	}

	#
	# this does the main work
	#
	function parse_resource_section
	{
		trace0 "for $TOKEN"
		local RES=$TOKEN
		get_token; expect "{"
		while get_token; do
			case "$TOKEN" in

			"}")
				break
				;;

			disk|net)
				parse_option_section
				;;

			on)
				get_token
				parse_host_section
				;;

			*=*)
				local key=${TOKEN%%=*}
				local val=${TOKEN##$key=}
				if mymatch "$TOKEN" "HOST_*" || ! fetch TEMPLATE "$key" ; then
					die "$PARSE: unknown option '$key'"
				fi

				check_token_type $RET_VAL

				store -new CONF "$RES:$key" "$val"
				;;

			*)
				local key=$TOKEN
				fetch TEMPLATE "$key" \
				|| { die "$PARSE: unknown option '$key'"; }

				check_token_type $RET_VAL

				case $RET_VAL in

				yes\ *)
					store -new CONF "$RES:$TOKEN" no ;;

				no\ *)
					store -new CONF "$RES:$TOKEN" yes ;;

				esac
			esac
		done
		[ "$TOKEN" == "}" ] || { die "$PARSE: unexpected end of file"; }
		fetch CONF "$RES:HOSTS"
		local HOSTS=$RET_VAL
		mymatch "$HOSTS"  "* $HOSTNAME *" \
		|| { die "$PARSE: This host ($HOSTNAME) not mentioned."; }
		set -- $HOSTS
		[ $# -lt 2 ] \
		&& { die "$PARSE: No partner host mentioned."; }

		check_if_all_parameters_set
	}

	#
	# global section
	#
	_did_global_section=no
	function parse_global_section
	{
		trace0
		local RES=$TOKEN
		test "$_did_global_section" = "yes" && { die "you can have only one global section"$'\n'; }
		get_token; expect "{"
		while get_token; do
			case "$TOKEN" in

			"}")
				break
				;;

			# TODO: GLOBAL_TEMPLATE and GLOBAL_CONF hashes?
			# allow default configuration values, e.g. syncer?
			minor_count=+([0-9]))
				MINOR_COUNT=${TOKEN#minor_count=}
				;;

			disable_io_hints)
				MODULE_OPTIONS=disable_io_hints
				;;

			*)
				die "invalid token in global section"$'\n'
				;;
			esac
		done
		[ "$TOKEN" == "}" ] || { die "$PARSE: unexpected end of file"; }
		_did_global_section=yes
	}

	# parse the configuration, and store this in source-able form
	# on the next invocation we try to read this pre-parsed config
	#
	function parse_config
	{
		trace0
		[ -z "$_SCRIPT_RECURSION" ] \
		&& echo "$link: pre-parsed needs update, parsing $CONFIG"

		if [ "$PROC_DRBD" == /proc/drbd -a "$CONFIG" == /drbd/drbd.conf ]
		then
		# If there are configured devices, and it was the newer CONFIG that
		# triggered the reread: warn
			local hot_devices
			hot_devices=$(sed '1d;2d;' < $PROC_DRBD | grep -v cs:\(Standalone\|Unconfigured\))
			if [ -e $CONFIG_PARSED ] && [ -n "$hot_devices" ] && [ $CONFIG -nt $CONFIG_PARSED ] ; then
				cat <<-_EOF

					$link: WARNING: change of configuration
					while drbd devices are configured!
					$hot_devices
				_EOF
				[ "$link" == datadisk ] && { die "use drbd stop first"$'\n'; }
				cat <<-_EOF
						I'll do what you say, but
						next time you should probably do 'drbd stop' first
						( or make this script more intelligent, so    )
						( this message is not triggered unnecessarily )

				_EOF
			fi
		fi

		# re-initialize, could be set by a failed attempt to use pre-parsed data
		CONF=(__hash__0)
		SEEN_RESOURCES=''

		debug 0 "sorry, this is bash, so parsing may take a while"
		local PARSE=""
		local TOKEN='' TOKEN_LINE='' TOKEN_LINE_NR=0

		while get_token; do
			if [ "$TOKEN" = "global" ]; then
				parse_global_section
				continue
			fi
			expect "resource"; get_token
			# resource name may be phony,
			# I restrict it to alphanums, dot, dash and underscore, though
			# QQQ should I allow umlauts?
			expect "+([._A-Za-z0-9-])"
			PARSE="resource '$TOKEN'"
			SEEN_RESOURCES="$SEEN_RESOURCES $TOKEN"
			parse_resource_section
			PARSE=""
		done < "$CONFIG" || { die "can not open <$CONFIG>"$'\n'; }
		CONFIG=''
		debug 2 "resources in $CONFIG:"
		debug 2 "  %s" $SEEN_RESOURCES
		[ $VERBOSITY -ge 2 ] && Dump CONF
		check_sanity
		if [ -z "$OPT_DRY_RUN" ] && [ "$COMMAND" != checkconfig ]
		then
			{   # store this config to avoid parsing again and again
				echo "SEEN_RESOURCES='$SEEN_RESOURCES'"
				echo "MINOR_COUNT='$MINOR_COUNT'"
				echo "MODULE_OPTIONS='$MODULE_OPTIONS'"
				Dump CONF
				echo "MD5SUM='$(md5sum < $CONFIG_PARSED)'"
			}  >| $CONFIG_PARSED \
			|| { die "cannot write to $CONFIG_PARSED"$'\n'; }
		else
			echo "parsed configuration NOT written to $CONFIG_PARSED"
		fi
	}

	# if we have a pre-parsed config, and the real config is not newer,
	# and this script has not changed since, read it.
	# if it seems self consistent, use it.
	#
	function read_parsed_config
	{
		trace0
		# has to exist ;)
		[ -e "$CONFIG_PARSED" ] \
	|| return 1

		# remove these lines, once the preparsed stuff works.
		# make normal runs less noisy again
		# [[ -z $_SCRIPT_RECURSION ]] \
		# && echo "$link: trying pre-parsed config $CONFIG_PARSED"

		# pre-parsed should be newer than config, and newer than this script
		[ $CONFIG_PARSED -nt $CONFIG \
		-a $CONFIG_PARSED -nt $0 ] \
	|| return 1

		source $CONFIG_PARSED
		# maybe someone accidentally changed *.parsed
		# if it was intentional, md5sum would have been updated.
		[ "$MD5SUM" == "$( grep -v ^MD5SUM= $CONFIG_PARSED | md5sum )" ] \
	|| return 1

		CONFIG=''
		[ $VERBOSITY -ge 2 ] && Dump CONF
		# check_sanity
		debug 1 "preparsed config $CONFIG_PARSED seems consistent"
		return 0 # ok
	}

	function check_one_parameter
	{
		case $val in
			__implicit__*|__optional__*|__appended__*)
				return ;;

			__required__*)
				fetch CONF "$RES:$key" \
				|| { die "$PARSE: required '$key' not set"; }
				;;

			*)
				fetch CONF "$RES:$key" \
				|| store -new CONF "$RES:$key" ${val%% *}
				;;
		esac
	}

	function check_if_all_parameters_set
	{
		trace0 "for $RES"
		local i tmp host key val
		set -- "${TEMPLATE[@]}"
		shift # the hash magic
		let i=1 ; while [ $i -lt $# ]; do
			tmp=${!i} ; let i=i+1
			val=${!i} ; let i=i+1
			if mymatch "$tmp" "HOST_*" ; then
				for host in $HOSTS ; do
					key=${tmp/HOST_/on $host:}
					check_one_parameter
				done
			else
				key=$tmp
				check_one_parameter
			fi
		done
	}

#
# Sanity Checking
###########################
# def: check_sanity check_disk check_device check_address_port
# def: multiply divide

	# arbitrary digit math for bash :-)
		# multiply number by factor
		#   yupa, bash can do arbitrary digits math
		#   well, unless factor is out of range too
		# please use positiv integers, or you get unexpected results
		function multiply
		{
			trace4
			RET_VAL=()
			[ -z "$1" -o -z "$2" ] && return
			# introduce new syntax, makes it readable
			mymatch "$1" "+([0-9])" && \
			[ "$2" == by ] && \
			mymatch "$3" "+([0-9])" \
			|| { die 'usage: multiply $N by $F'; }
			local N F R r
			N=$1 F=$3 r=0
			n=${N: -1}
			until [ -z "$N" -a -z "$r" ]; do
				N=${N%?}
				r=$(( ${n:-0} * $F + ${r:-0} ))
				R=${r: -1}$R
				r=${r%?}
				n=${N: -1}
			done
			RET_VAL=(${R##+(0)})
			debug 4 "$FUNCNAME returns (%s)" "${RET_VAL[*]}"
		}

		# divide <nominator> by denominator>
		#   yupa, bash can do arbitrary digits math
		#   well, unless denominator is out of range too
		# please use positiv integers, or you get unexpected results
		function divide
		{
			trace4
			RET_VAL=()
			[ -z "$1" -o -z "$2" ] && return
			# introduce new syntax, makes it readable
			mymatch "$1" "+([0-9])" && \
			[ "$2" == by ] && \
			mymatch "$3" "+([0-9])" \
			|| { die 'usage: divide $nominator by $denominator'; }
			local N D F n f r
			N=$1 D=$3
			n=${N::1}
			while [ -n "$N" ]; do
				N=${N#?}
				f=$(( $n / $D ))       # current factor
				F=$F$f                 # cumulated factor
				r=$(( $n - $f * $D ))  # reminder
				n=${r#0}${N::1}
			done
			RET_VAL=(${F##+(0)})
			debug 4 "$FUNCNAME returns (%s)" "${RET_VAL[*]}"
		}

	# check_disk
	# underlying block device
	function check_disk
	{
		local size_in_kB conf_disk_size unit
		local size_in_sectors sector_size_in_byte
		trace "for $res on $host"
		local disk
		fetch CONF "$res:on $host:disk"; disk=$RET_VAL
		if fetch Disk "$disk"; then
			die "Disk $disk is used by $res($host) and $RET_VAL"$'\n'
		else
			store -new Disk "$disk" "$res($host)"
			# check the device size
			if ! size_in_sectors=$(blockdev --getsize $disk) ; then
				echo "$link: warning: could not get size of $disk"
	return
			else if [ $size_in_sectors == 0 ] ; then
				echo "$link: warning $disk has zero size?"
	return
			fi; fi
			if ! sector_size_in_byte=$(blockdev --getss $disk) ; then
				echo "$link: warning: could not get sector size of $disk, assuming 512"
				sector_size_in_byte=512
			fi
			multiply "$size_in_sectors" by "$sector_size_in_byte"
			# now byte -> kB
			divide "$RET_VAL" by 1024
			size_in_kB=$RET_VAL

			fetch CONF "$res:disk"
			set -- $RET_VAL
			while [ -n "$1" ] && ! mymatch "$1" "--disk-size=*" ; do shift ; done

			if [ -n "$1" ]; then
				conf_disk_size=$1
				# this is not to be returned, it is to make coding easier
				RET_VAL=(${1##*--disk-size=})
				RET_VAL=${RET_VAL%[kMG]}
				case "$conf_disk_size" in
				*G) multiply "$RET_VAL" by 1048576 ;; # 1024*1024
				*M) multiply "$RET_VAL" by 1024 ;;
				# default unit: kB
				esac
				conf_disk_size=$RET_VAL
				if [ ${#conf_disk_size} -gt ${#size_in_kB} ] \
				   || [ ${#conf_disk_size} -eq ${#size_in_kB} \
				      -a $conf_disk_size -gt $size_in_kB ]
				then
					die "configured $1 for '$res' is too large" \
					    "\n    $conf_disk_size > $size_in_kB kB"
				else
					debug 1 "$res: $1: $conf_disk_size <= $size_in_kB"
				fi
			else
				echo "$link: disk-size not specified."
				echo "$link: you should set disk-size to no more than $size_in_kB"
			fi
		fi
	}

	# check_device
	# this is /dev/nb#
	function check_device
	{
		trace "for $res on $host"
		local device
		fetch CONF "$res:on $host:device"; device=$RET_VAL
		if fetch Device "$device"; then
			die "Device $device is used by $res($host) and $RET_VAL"$'\n'
		else
			store -new Device "$device" "$res($host)"
		fi
	}

	# executes the given arguments as command line, but kills
	# that process if it does not return within the timeout
	# defaults to 3 seconds, can be given as first option argument
	# returns the exit code of the command,
	# or 143 ("killed by SIGTERM") on timeout.
	function timeout_exec {
		local timeout=3
		mymatch "$1" "-[0-9]*" && { 
			timeout=${1#?}
			shift
		}
		bash -c '
				ex=143 kid=
				trap '\''[[ $kid ]] && kill -TERM $kid; exit $ex'\'' TERM
				(sleep '"$timeout"'; kill -TERM $$) &> /dev/null &
				sleep_pid=$!
				"$@" &
				kid=$!
				wait $kid
				ex=$?
				kid=
				kill -TERM $sleep_pid
				exit $ex
				' -- "$@"
	}

	function check_address_port
	{
		trace "for $res on $host"
		local tmp
		fetch CONF "$res:on $host:address"; tmp=$RET_VAL
		$PING $tmp &> /dev/null
		[ $? -eq 1 -o $? -eq 143 ] && echo "$link: WARN: $host [$tmp] does not respond to ping"

		fetch CONF "$res:on $host:port"
		tmp="$tmp:$RET_VAL"
		if fetch Address_Port "$tmp" ; then
			die "Adress/port $tmp is used by $res($host) and $RET_VAL"$'\n'
		else
			store -new Address_Port "$tmp" "$res($host)"
		fi
	}

	# does some sanity checks over all resources
		# - uniqueness of device and disk resources on this host
		# - uniqueness of combination ip:port on all hosts
		#
		# XXX does NOT yet check
		# - uniqueness of ip address over all hosts
		#   (you will notice by other means for sure)
		# - equivalence of config files on partner hosts
		# - [ fill in what tests you think could make sense ]
		#
	function check_sanity
	{
		trace "for $SEEN_RESOURCES"
		local res host
		declare -a Disk=(__hash__0)
		declare -a Device=(__hash__0)
		declare -a Address_Port=(__hash__0)

		for res in $SEEN_RESOURCES; do
			fetch CONF "$res:HOSTS"
			for host in $RET_VAL ; do
				# network resource check on all hosts
				check_address_port
				[ "$host" == "$HOSTNAME" ] || continue
				# disk and device check only on localhost
				check_disk
				check_device
			done
		done
		debug 1 "config seems sane: good ..."
	}

#
# command helpers
###########################
# def: assure_module_is_loaded configure become_active become_passive
# def: get_drbd_status connection_status datadisk_status reconnect
# def: wait_until_partner_passive wait_connect wait_sync ask_for_abort
# def: user_abort dialog_or_drbdsetup_failed connection
# def: connect_and_sync

	# assure_module_is_loaded <device> <device> ...
		# count of positional arguments is used as
		# minor_count parameter to modprobe
		MINOR_COUNT=''
		MODULE_OPTIONS=''
	function assure_module_is_loaded
	{
		trace4
		[ -e "$PROC_DRBD" ] && return

		test -z "$MINOR_COUNT" && MINOR_COUNT=$#
		if [ "$MINOR_COUNT" -lt $# ]; then
			echo "set minor_count parameter to number of seen resources: $#"
			MINOR_COUNT=$#
		fi

		debug 1 "$MODPROBE -s drbd minor_count=$#"
		$MODPROBE -s drbd minor_count=$MINOR_COUNT $MODULE_OPTIONS \
		|| { die "Can not load the drbd module."$'\n'; }
	}

	# mount_status <device>
	# RET_VAL=''|rw|ro
	function mount_status
	{
		trace4
		local device=$1
		mounts=$(</proc/mounts)
		IFS=$'\n' ; set -- $mounts ; IFS=$' \t\n'
		while [ -n "$1" ] && ! mymatch "$1" "$device *"; do shift; done

		set -- $1
		RET_VAL=(${4%%,*} $*)
		debug 4 "$FUNCNAME returns (%s)" "${RET_VAL[*]}"
	}

	# configure <device>
	# implements drbd start
	function configure
	{
		trace0
		local res=$1
		local errtxt device command host

		get_drbd_status $res
		if [ -z "$OPT_DUMMY" -a -z "$OPT_DRY_RUN" ] \
			&& [ $RET_VAL != Unconfigured ]
		then
			echo -e "\n$link: WARN: '$res' already configured. I'll do what you say,"
			echo -e "$link: but it should probably be '$link $res restart'\n"
		fi

		fetch CONF "$res:on $HOSTNAME:device"
		device=$RET_VAL

		command="$DRBD_SETUP $device disk"
		fetch CONF "$res:on $HOSTNAME:disk"
		command="$command $RET_VAL"

		fetch CONF "$res:disk"
		command="$command $RET_VAL"

		echo -n "Setting up '$res'..."
		debug 1 "$command"
		[ -n "$OPT_DRY_RUN" ] && $command
		errtxt=$($command 2>&1) || { die "$errtxt"$'\n'; }

		reconnect $res
		echo "[ OK ]"
	}

	# become_active <resource>
		#
	function become_active
	{
		trace0
		local res=$1 ret
		local errtxt device command fsckcmd mounts incondegcmd

		fetch CONF "$res:on $HOSTNAME:device"
		device=$RET_VAL

		get_drbd_status $res
		if [ "${RET_VAL[0]}" == Unconfigured ] ; then
			echo "$link: '$res' is not configured"
			echo "$link: please call 'drbd $res start' first"
			# TODO could try to configure right here myself.
			# but that involves too much, since I should wait for connection and so on.
			# or I could call out to drbd start here. but why not educate the user?
			# The bug was in drbd(setup) anyways, since drbd sets its state to
			# Primary happily on an unconfigured device!
			# update: last statement is no longer true, that has been fixed in the module...
	exit -1
		fi
		if [ "${RET_VAL[1]}" == Primary ] ; then
			[ "${RET_VAL[2]}" == Primary ] \
			&& { die "Error: Both hosts in Primary state on '$res'"; }
			echo "$link: '$res' already in Primary state, checking mount status"
		else
			# try to become primary, die on error
			command="$DRBD_SETUP $device primary"
			debug 1 "$command"
			[ -n "$OPT_DRY_RUN" ] && $command
			errtxt=$($command 2>&1)
			ret=$?
			if [ $ret = 21 ]; then
			    fetch CONF "$res:incon-degr-cmd"
			    incondegrcmd=$RET_VAL
			    [ "$incondegrcmd" = "0" ] && { die "$errtxt"$'\n'; }
			    errtxt=$($incondegrcmd 2>&1) || { die "$incondegrcmd FAILED\n$errtxt"$'\n'; }
			elif [ $ret -ne 0 ]; then
				die "$errtxt"$'\n';
			fi
		fi

		# ok, primary now
		# is device mounted?
		mount_status $device
		if [ -z "$RET_VAL" ] ; then
			fetch CONF "$res:fsckcmd"
			fsckcmd=$RET_VAL
			debug 1 "$fsckcmd $device"
			if [ -n "$OPT_DUMMY" -a -n "$OPT_DRY_RUN" ] ; then
				fsckcmd="echo # $fsckcmd"
			fi
			$fsckcmd $device; ret=$?
				case $ret in
				0) :;;
				1) echo "$fsckcmd found and corrected some errors";;
				*) die "$fsckcmd $device FAILED"$'\n';; 
				esac
			debug 1 "$MOUNT $device"
			$MOUNT $device || { die "mount $device FAILED"$'\n'; }
		else
			echo -n "$link: $device already mounted "
			if [ "$RET_VAL" == rw ] ; then
				echo rw
			else
				echo ro, NOT remounted
				# QQQ should we try to remount it?
				#
				# debug 1 "$MOUNT $device -o remount,rw"
				# $MOUNT $device -o remount,rw
			fi
		fi
	}

	# become_passive <resource>
	# RET_VAL=($errtxt $device)
	function become_passive
	{
		trace0
		local res=$1
		local errtxt device command

		get_drbd_status $res
		[ "$RET_VAL" == Unconfigured ] \
	&& return

		fetch CONF "$res:on $HOSTNAME:device"
		device=$RET_VAL
		mount_status $device
		if [ -n "$RET_VAL" ]; then
			echo -e "$link: $device is mounted on ${RET_VAL[2]}, trying to umount"
			debug 1 "$UMOUNT $device"
			$UMOUNT $device &> /dev/null \
			|| {
				# umount failed, kill all processes accessing <device>
				debug 1 "$FUSER -k -m $device"
				$FUSER -k -m $device > /dev/null
				sleep 3 # hopefully the signals get delivered within this time
				# try again
				debug 1 "$UMOUNT $device"
				[ -n "$OPT_DRY_RUN" ] && $UMOUNT $device
				errtxt=$($UMOUNT $device 2>&1) \
				|| {
					# failed again, FATAL
					die "$link: $UMOUNT $device FAILED:\n$errtxt"$'\n'
				}
			}
		fi

		# ok, <device> now unmounted,
		# try to become secondary, return on success
		command="$DRBD_SETUP $device secondary"
		debug 1 "$command"
		[ -n "$OPT_DRY_RUN" ] && $command
		errtxt=$($command 2>&1) \
	&& return

		# could not become secondary
		# we might be in resync
		# error will be handled by caller
		if mymatch "$errtxt" "?(*$'\n')Resynchroni*" ; then
			RET_VAL=("$errtxt" $device)
	return 1
		fi

		# drbdsetup secondary failed
		# and we are not in resync.
		# FATAL
		die "'$command' FAILED:\n$errtxt"$'\n';
	}


	# get_drbd_status <resource>
		# parses /proc/drbd for line describing <resource>
		# if <device> is not found, dies
		#
		# sets RET_VAL:
		#	[0] connection status
		#	[1] state of this host
		#	[2] state of partner host
		#
	function get_drbd_status
	{
		trace
		RET_VAL=()
		fetch CONF "$1:on $HOSTNAME:device"
		local device=$RET_VAL
		local major minor line progress_line='' ls_pattern

		[ -b "$device" ] || { die "'$device' is not a block device"; }

		# (?) bash has no stat command.
		# use ls for determining device numbers
		line=$(/bin/ls -nl $device)
		ls_pattern="brw-[r-][w-]-[r-]--+( )+([0-9])+( )+([0-9])+( )+([0-9])+( )+([0-9]),+( )+([0-9])*$device"
		mymatch "$line" "$ls_pattern" \
		|| { die "ls '$device':\n$line\nparse error, could be wrong permissions" ; }

		# split $line on white space into $*
		set -- $line
		major=${5%,}
		minor=$6

		# QQQ check for device major, warn if unexpected. maybe should even die?
		#     can this happen? or does drbd refuse to configure such a device...
		[ "$major" == 43 ] || echo "$link: WARN: $device major is not 43; you risk deadlock"

		while read line ; do
			# yep, pattern matching in bash is noisy
			# would it be sufficient to check for "$minor:*" ?
			mymatch "$line" "$minor:\ cs:+([[:alnum:]])\ st:+([[:alnum:]])/+([[:alnum:]])*" \
		    || continue
			# split line on " :/" into $*
			IFS=$' :/'; set -- $line ; IFS=$' \t\n'
			if [ "$3" == SyncingAll ] ; then
				# if read is used this way, it does not strip leading blanks.
				read ; progress_line=$REPLY$'\n'
				read ; progress_line=$progress_line$REPLY$'\n'
				# only if there were the too additional progress bar lines
				mymatch "$progress_line" $'\t*' || progress_line=''
			fi
			RET_VAL=($3 $5 $6 "$progress_line")
			debug 4 "$FUNCNAME returns (%s)" "${RET_VAL[*]}"
	return
		done <$PROC_DRBD || { die "can not open $PROC_DRBD"$'\n'; }
		die "Minor for $device ($res) not found in $PROC_DRBD"$'\n'
	}

	# connection_status <resource>
		#
	function connection_status
	{
		trace0
		RET_VAL=()
		get_drbd_status $1
		if [ "${RET_VAL[1]}" == Primary \
		-a "${RET_VAL[2]}" == Primary ] ; then
			RET_VAL=("error")
			debug 4 "$FUNCNAME returns (%s)" "${RET_VAL[*]}"
	return
		fi
		case $RET_VAL in
    		Unconfigured  |\
			StandAlone    |\
			Unconnected   |\
			Timeout       |\
			BrokenPipe    |\
			WFConnection  |\
			WFReportParams)
				RET_VAL=("stopped") ;;

			Connected     |\
			SyncingAll    |\
			SyncingQuick  )
				RET_VAL=("running" "${RET_VAL[3]}") ;;
		esac
		debug 4 "$FUNCNAME returns (%s)" "${RET_VAL[*]}"
	}

	# datadisk_status <resource>
		#
	function datadisk_status
	{
		trace4
		RET_VAL=()
		get_drbd_status $1
		case ${RET_VAL[1]} in
    		Primary   )
				if [ "${RET_VAL[2]}" == Primary ] ; then
					RET_VAL=("error")
				else
					RET_VAL=("running")
				fi ;;

			Unknown   |\
			Secondary )
				RET_VAL=("stopped") ;;
		esac
		debug 4 "$FUNCNAME returns (%s)" "${RET_VAL[*]}"
	}

	# reconnect <resource>
	# implements drbd reconnect
	# called by configure, too
	function reconnect
	{
		trace0
		local res=$1
		local errtxt host command

		get_drbd_status $res
		if [ -z "$OPT_DUMMY" -a -z "$OPT_DRY_RUN" ] \
			&& [ "$RET_VAL" == @(Connected|Syncing*) ]
		then
			echo -e "\n$link: WARN: '$res' is in $RET_VAL state."
			echo -e "$link: I'll do what you say, but why do you reconnect?\n"
		fi


			# build up the command line; do it piece by piece
			command=$DRBD_SETUP
			host=$HOSTNAME

			fetch CONF "$res:on $host:device"
			command="$command $RET_VAL net"

			fetch CONF "$res:on $host:address"
			command="$command $RET_VAL"
			fetch CONF "$res:on $host:port"
			command="$command:$RET_VAL"

			fetch CONF "$res:HOSTS"
			set -- ${RET_VAL/ $host /}
			host=$1

			fetch CONF "$res:on $host:address"
			command="$command $RET_VAL"
			fetch CONF "$res:on $host:port"
			command="$command:$RET_VAL"

			fetch CONF "$res:protocol"
			command="$command $RET_VAL"

			fetch CONF "$res:net"
			command="$command $RET_VAL"

		debug 1 "$command"
		[ -n "$OPT_DRY_RUN" ] && $command
    	errtxt=$($command 2>&1) || { die $errtxt$'\n'; }
	}

	# wait_until_partner_passive <resource>
	function wait_until_partner_passive
	{
		trace0
		local res=$1 device

		get_drbd_status $res
		if [ "${RET_VAL[2]}" == Primary ] ; then
		# QQQ should we send secondary_remote?
			# fetch CONF "$res:on $HOSTNAME:device"
			# device=$RET_VAL
			# debug 1 "$DRBD_SETUP $device secondary_remote"
			# $DRBD_SETUP $device secondary_remote
		    echo "Waiting until partner node is secondary on '$res'; <CTRL-C> for abort"
			get_drbd_status $res
			until [ "${RET_VAL[2]}" != Primary ] ; do
				sleep 5
				# $DRBD_SETUP $device secondary_remote
				get_drbd_status $res
			done
		fi
	}

	# wait_connect <resource>
		# waits for connection, may be interrupted
		# on SIGINT propagate SIGTERM to DRBD_SETUP, because somehow
		# bash installs an ignore handler on INT, which is inherited.
		# I could set -m (job-control) but then I got other problems.
	function wait_connect
	{
		trace
		local res=$1
		local device

		fetch CONF "$res:on $HOSTNAME:device"
		device=$RET_VAL

		fetch CONF "$res:inittimeout"
		RET_VAL=${RET_VAL#-}

		$DRBD_SETUP $device wait_connect -t $RET_VAL &
		trap "kill -TERM $! &> /dev/null ; exit 0" INT
		debug 1 "[$!] $DRBD_SETUP $device wait_connect -t $RET_VAL"
		wait $!                # || or do something sensible if drbdsetup failed...
	}

	# wait_sync <resource>
		# waits for synchronization to finish
		# may be interrupted, but answering 'yes' to user dialog will *not*
		# force a connected/syncing device into Primary state, although it will
		# terminate the drbdsetup wait_sync task
	function wait_sync
	{
		trace
		local res=$1
		local device

		fetch CONF "$res:on $HOSTNAME:device"
		device=$RET_VAL

		get_drbd_status $res
		if ! mymatch "$RET_VAL" "Syncing*" ; then
			echo -e "\n'$res' is not Syncing."
			return
		fi
		if [ "${RET_VAL[1]}" == Secondary ] ; then
			echo -e "\nWaiting until '$res' is up to date (using $RET_VAL)"
			$DRBD_SETUP $device wait_sync &
			# QQQ can we somehow see/show the progress of synchronization?
			# similar to /proc/mdstat?

			trap "kill -TERM $!; exit 0" INT
			debug 1 "[$!] $DRBD_SETUP $device wait_sync"
			wait $!
			echo kill -USR2 $$
			kill -USR2 $$

			debug 1 "$DRBD_SETUP $device secondary_remote"
			$DRBD_SETUP $device secondary_remote &> /dev/null
			# No error check here, on purpose!
		else
			echo -e "\nI have the good data. No need to wait"
			echo    "until '$res' is up to date (using $RET_VAL)"
		fi
	}

	# ask_for_abort
	# expects to be run asynchronously
	# on user confirmation kills parent shell with SIGUSR1
	# if read failed (eof/no tty/user hits ^C) kills parent with SIGQUIT
	#
	function ask_for_abort
	{
		trace4
		local prompt ans
		prompt='Do you want to abort waiting for other server and make this one primary?'$'\n'
		while read -p "$prompt" ans || return 1 ; do
			[ "$ans" == yes ] && break
			prompt='Answer either "yes" or not at all: '
		done
		return 0
	}

	# called on 'yes'
	# forces primary state on the remaining devices
	function user_abort
	{
		trace4
		local res errtxt
		# don't know, whether our USR2 trap could interfere.
		# disable it, just in case.
		trap "" USR2
		kill -INT ${wait_for[*]} &> /dev/null
		for res in ${resources[*]// *} ; do
			fetch CONF "$res:on $HOSTNAME:device"
			debug 1 "$DRBD_SETUP $RET_VAL primary --human"
			[ -n "$OPT_DRY_RUN" ] && $DRBD_SETUP $RET_VAL primary --human
			errtxt=$($DRBD_SETUP $RET_VAL primary --human 2>&1) \
			|| { die "$errtxt"$'\n'; }
		done
	}

	function dialog_or_drbdsetup_failed
	{
		trace4
		trap "" USR1 USR2 QUIT
		# mute the kill, we probably have some dead children which are still listed
		kill -INT ${wait_for[*]} $user &> /dev/null
		die "asynchronous job terminated abnormally"$'\n'
	}

	#
	# this is a "reaper",
	# try to determine who sent the SIGUSR2 or the -ALRM
	# and delete him from our lists
	#
	function connection # established | timed_out
	{
		trace4
		local i reaped=0 retry=1 status=$1 wait_sync=""
		while true; do # retry loop
		let i=-1 ; while [ $i -lt $wait_count ]; do let i=i+1
			[ -n "${wait_for[i]}" ] || continue
			kill -0 ${wait_for[i]} &> /dev/null && continue

			get_drbd_status ${resources[i]}
			if [ "${resources[i]:0:1}" != " " ] ; then
				#
				# we have a race here! FIXME QQQ
				# if someone died with -ALRM and the other died with -USR2
				# _at the same time_ (to bash, that is), the -ALRM one can
				# be mistaken as -USR2, and not be forced to primary;
				# or even worse, the -USR2 one can be forced to primary in
				# error!
				# I'll try to fix it this way:
				# not if [ "$status" == timed_out ] ; then
				# but effectively ignoring the parameter given to this
				# function, and thus the difference between -ALRM and -USR2
				#
				# And an other one: signal handling might be too slow
				# if for some reason the connection breaks in the moment it is
				# first established. In that case the proc read returns
				# WFConnection again, and so it seems like the connection timed
				# out. Thus the problem gets even worse.
				# ergo: you should not set inittimeout to any positive value,
				# if you have an other option.
				#
				if [ "$RET_VAL" == WFConnection ] ; then
					echo "WARNING: [${wait_for[i]}] ${resources[i]}:"\
						"connection timed out"
					fetch CONF ${resources[i]}:inittimeout
					if [ "${RET_VAL::1}" == "-" ] ; then
						echo "I'll let the cluster manager decide..."
					else
						echo -e "\tforcing primary status --"\
							"DATA INTEGRITY MAY BE COMPROMISED."
						fetch CONF ${resources[i]}":on $HOSTNAME:device"
						debug 1 "$DRBD_SETUP $RET_VAL primary --timeout-expired"
						$DRBD_SETUP $RET_VAL primary --timeout-expired 2>&1
					fi
				elif [ "$RET_VAL" == StandAlone ] ; then
						echo -n "WARNING: [${wait_for[i]}] ${resources[i]}:"\
							"Unable to connect. "
					if [ "${RET_VAL[2]}" == IncompatRel ] ; then
						# not yet implemented ;)
						echo "Different drbd releases?"
					else
						echo "Something is screwed up here ..."
						# so for the moment beeing put this message here, too.
						echo "Different drbd releases?"
					fi
				else
					debug 1 "[${wait_for[i]}] ${resources[i]}: connection established"
					fetch CONF "${resources[i]}:skip-wait"
					if mymatch "$RET_VAL" "@(yes|on|true|1)"; then
						echo "$link: skip-wait for '${resources[i]}'"
					else
						# *What?* spawn kids in signal handler?
						# well, yes. have to. don't like it, but it seems to work.
						( trap "exit 0" INT; wait_sync ${resources[i]} ) &
						# store this pid, so it gets killed on INT
						wait_sync=$!
						echo "[$!] wait_sync '${resources[i]}'"
					fi
				fi
			elif [ "${RET_VAL[1]}" == Secondary ]; then
				echo "[${wait_for[i]}] '${resources[i]// }': synchronization finished"
			else
				echo "[${wait_for[i]}] '${resources[i]/ }' "${RET_VAL[3]}
			fi
			wait_for[i]=$wait_sync  # only set if we actually spawned a new process

			# prepend a " " so it won't be forced by 'yes' to primary --human
			resources[i]=" ${resources[i]}"
			# no break, since several kids could have died at the same time
			let reaped=reaped+1
		done
		# sometimes bash sees only one signal, when two are
		# delivered at almost the same time. sometimes reception
		# is delayed, and we reaped it in a previous loop together
		# with some other child.
		# sometimes the signal is here *before* the child is dead,
		# since it is sent by the child itself.
		# then we get confused.
		[ $reaped -eq 0 -a $retry -le 1 ] && {
			# none has been reaped. retry.
			debug 1 "signal too fast. retry $retry"
			let retry=retry+1
			sleep 1  # wait for child to die.
					 # since it sent the USR2 itself, it was alive just now
			continue
		} || debug 1 "noone reaped. strange!"
		break
		done

		# connecting childs left?
		set -- ${resources[*]// *}
		if [ $# -gt 0 ] ; then
			echo "still waiting for connection:" $*
		else
			# no more wait_connects --> terminate user dialog
			kill -TERM $user &> /dev/null
		fi
	}

	# connect_and_sync ... this one is tricky
		# Wait for partner to get ready, but include timeout and operator dialog.
		# The wait builtin accepts one particular pid to wait for, or none at
		# all. In the latter case it waits for all children to finish before
		# continuing.
		# So use callback functions and deliver the signals ourselves.
		# confirmed dialog       sends USR1
		# established connection sends USR2
		# when all wait_connects have finished, TERM is send to the user dialog
		#
		# if one of them fails, QUIT is send, which in turn causes INT to be
		# send to all kids, and exit
		#
	function connect_and_sync
	{
		trace0
		local res user wait_count=0
		declare -a wait_for=()
		declare -a resources=()

		trap 'user_abort'                 USR1
		trap 'connection established'     USR2
		trap 'connection timed_out'       ALRM
		trap 'dialog_or_drbdsetup_failed' QUIT

		trap "" INT # parent script ignores INT

		for res in $DO_RESOURCES ; do
			fetch CONF "$res:load-only"
			if mymatch "$RET_VAL" "@(yes|on|true|1)"; then
				debug 0 "$link: load-only for '$res'"
				continue
			fi
			(# sends USR2 when connection is established
				wait_connect $res
				ret=$?;
				case $ret in
				0) sig="-USR2";; # connected
				1) sig="-ALRM";; # inittimeout
				*) sig="-QUIT";;
				esac
				sleep 1 # if they find each other immediately, they could try to
						# terminate the user dialog before it had time to startup...
				kill $sig $$
			) &
			wait_for[wait_count]=$!
			resources[wait_count]=$res
			debug 1 "[$!] wait_connect '$res'"
			let wait_count=wait_count+1
		done

	# no wait_connects; so whom would I wait for?
	[ $wait_count -gt 0 ] || return 0

		echo "waiting for connection:" ${resources[*]}

		(
			# on confirm ("yes"): USR1
			(
				trap "exit 1" INT
				trap "echo 'All resources connected.'; exit 0" TERM
				sleep 3         # show the prompt with a little delay.
				ask_for_abort && kill -USR1 $$
			)  < $TERMINAL &> $TERMINAL &
			debug 1 "[$!] ask_for_abort"

			# on INT, propagate; this is <CTRL-C> by user or generated in
			# dialog_or_drbdsetup_failed
			# so not exit, but let the QUIT below take effect.
			trap "kill -INT $! &> /dev/null" INT
			# on TERM: propagate
			# this is send by the last syncer_done
			trap "kill -TERM $! &> /dev/null" TERM
			wait $!
			# on non clean exit,
			# that is non zero exit code and not killed by SIGTERM,
			# send QUIT
			[ $? == 0 -o $? == $((128 | 15)) ] || kill -QUIT $$
			# just in case
			# wait semantic has changed in recent versions of bash
			wait $! &> /dev/null
		) &
		user=$!

		# wait for all children
		# the traps above will do the work
		while true ; do wait && break || debug 1 "wait exit code $?"; done
		#connection "all done :)" # to "reap" the last one, too

		# restore default INT handler for parent; since we leave anyways, this
		# is just to be explicit.
		trap - INT

		debug 1 "helpers done, checking whether we are actually Connected"
		for res in $DO_RESOURCES ; do
			get_drbd_status $res
			if [ "$RET_VAL" != Connected ] ; then
				echo "$link: '$res' still not in Connected state, but $RET_VAL"
				echo -n "${RET_VAL[3]:+${RET_VAL[3]}}"
			fi
		done
	}


# once I do error checking on each simple command, I can leave it on
# -e during execution, too
trap - EXIT
set +e

#
# frame work for commandline options
#
	STARTDIR=`pwd`;
	PARAMETERS=`$GETOPT "$@"` \
	|| print_usage_and_exit
	# eval to strip possible quoting by getopt
	eval "set -- $PARAMETERS"

	while true; do
	case $1 in

	--dry-run)
		OPT_DRY_RUN='yes'; shift
		[ -z "$_SCRIPT_RECURSION" ] \
		&& cat <<-_EOF

			--dry-run
			  I will only echo the commands that would have been executed.
			  Sequence of commands might be not identical to real run.

		_EOF
		MODPROBE="echo # modprobe"
		RMMOD="echo # rmmod"
		UMOUNT="echo # umount -v"
		MOUNT="echo # mount -v"
		FUSER="echo # fuser"
		TOUCH="echo # touch"

		DRBD_SETUP="echo # drbdsetup"
		PROC_DRBD="/proc/drbd"
		# CONFIG is set elsewhere, otherwise the dry run would be biased

		PING="echo # ping -c 1 -w 3"
		;;

	--dummy)
		OPT_DUMMY='yes'
		# debugging of the script without running drbdsetup
		[ "$VERBOSITY" == "-1" ] && VERBOSITY=3
		cat <<-_EOF

			WARNING
			  debugging enabled, using dummy programs and file locations
			  you should not use this mode unless you have the files I point to

		_EOF
		DRBD_SETUP="$STARTDIR/try/mysleep" # this is a very simple C program
		                         # to check if signal delivery works as intended.
		                         # loop {sleep(1); printf(i);} on wait_{sync,connect}
		                         # and simply returns on other
		MODPROBE="true"
		RMMOD="true"
		UMOUNT="true"
		MOUNT="true"
		FUSER="true"
		TOUCH="touch"       # otherwise --parse would not work

		# point to text files for debugging
		PROC_DRBD="$STARTDIR/try/proc.drbd"

		CONFIG=${OPT_CONFIG:-"$STARTDIR/try/drbd.conf"}
		[ "${CONFIG::1}" == "/" ] || CONFIG=$STARTDIR/$CONFIG_PARSED
		CONFIG_PARSED="$CONFIG.parsed"

		if ! [ -f $PROC_DRBD ] && [ -f $CONFIG ] && [ -x $DRBD_SETUP ] ; then
			CONFIG='';
			die "can not find all necessary files for dummy mode\nDid you mean --dry-run?"$'\n';
		fi

		[ $VERBOSITY -gt 4 ] && Dump TEMPLATE
		shift
		;;

	--parse)
		OPT_FORCE_PARSE='yes'; shift
		;;

	--config*)
		# in case getopt was not found, and user used --config=file syntax
		OPT_CONFIG=$1; shift
		mymatch "$OPT_CONFIG" "--config=*" && set -- "${OPT_CONFIG##--config=}" "$@"

		# option ordering on command line is no longer important with dummy mode
		OPT_CONFIG=$1
		CONFIG=$OPT_CONFIG
		# not standard config, must not be stored in /var/lib/drbd/
		CONFIG_PARSED=$CONFIG.parsed
		shift
		;;

	--info)
		printf "%-14s: %s\n" BASH_VERSINFO "${BASH_VERSINFO[*]}"
		for v in CVSID CONTACT TERMINAL MODPROBE RMMOD UMOUNT MOUNT TOUCH \
			DRBD_SETUP PROC_DRBD CONFIG CONFIG_PARSED
		do
			printf "%-14s: %s\n" $v "${!v:-# is not set}"
		done
		print_usage_and_exit
		;;

	# template
		# --*)
		# 	OPT_*='yes'; shift
		# 	# do something useful
		# 	;;

	--)	# end options
		shift; break
		;;

	-*)
		# if no getopt was available, do this here
		CONFIG='' # mute the in <CONFID> line in die_at
		die "unknown option $1"$'\n'
		;;

	*)	break ;; # not an option, but real argument

	esac
	done

	# outside the loop, to make it independend of position
	# if used together with --config or --dummy
	[ -n "$OPT_FORCE_PARSE" ] && $TOUCH -c $CONFIG


function needs_to_be_root
{
	[ -n "$OPT_DUMMY" ] || [ -n "$OPT_DRY_RUN" ] || [ -n "$OPT_CHECK_ONLY" ] && return
	if [ "$EUID" != 0 ] ; then
		echo "$link: you have to be root to $COMMAND"
		exit -1
	fi
}

#
# "Main" Program, datadisk or drbd
# depending on basename of this script
###########################


debug 0 "CVS ${CVSID//\$/}\n\n$link $*\n"
[ $# == 2 ] && { RESOURCE=$1; shift; }
[ $# == 1 ] && { COMMAND=$1 ; shift; } \
|| print_usage_and_exit

# since I keep saying 'drbd start device'
# instead of 'drbd device start'
if mymatch "$RESOURCE" "@(start|stop|status|reconnect|checkconfig)" ; then
	debug 0 "swapping COMMAND and RESOURCE arguments"
	_COMMAND=$RESOURCE; RESOURCE=$COMMAND; COMMAND=$_COMMAND
	unset _COMMAND
fi
if mymatch "$COMMAND" "@(start|stop|restart|reconnect)" ; then
	needs_to_be_root
fi

#
# read pre-parsed config, or if this seems inconsistent,
# parse again
#
read_parsed_config || parse_config

# I do not want to kill myself in drbd stop
# but for restart I need to remember who I am
mymatch "$0" "/*" && DRBD=$0 || DRBD="$PWD/$0"
cd /

DO_RESOURCES=$SEEN_RESOURCES
if [ -n "$RESOURCE" ] ; then
	fetch CONF "$RESOURCE:HOSTS"
	[ -n "$RET_VAL" ] \
	|| { die "resource '$RESOURCE' not defined in config file (defined:$SEEN_RESOURCES)"$'\n'; }
	DO_RESOURCES=$RESOURCE
fi

# for now, do not use alternate config files without dummy mode
if [ -n "$OPT_CONFIG" ] && [ -z "$OPT_DUMMY" ] ; then
	OPT_CHECK_ONLY='*'
	link=drbd
fi

case $link in

drbd)

	case $COMMAND in

	checkconfig|$OPT_CHECK_ONLY)
		# on VERBOSITY level >= 2 this is done above already.
		[ $VERBOSITY -lt 2 ] && Dump CONF
		cat <<-_EOF

		  ${OPT_CHECK_ONLY:+Alternate config specified, but not in dummy mode,}
		  ${OPT_CHECK_ONLY:+forced behavior is drbd checkconfig.}
		  Configuration seems useable.
		  If it does not work, you might have found a bug in this script.

		_EOF
		;;

	restart)
		export _SCRIPT_RECURSION=yes
		$DRBD \
			${OPT_CONFIG:+--config=$OPT_CONFIG} \
			${OPT_DUMMY:+--dummy} \
			${OPT_DRY_RUN:+--dry-run} \
			$RESOURCE stop \
		&& \
		$DRBD \
			${OPT_CONFIG:+--config=$OPT_CONFIG} \
			${OPT_DUMMY:+--dummy} \
			${OPT_DRY_RUN:+--dry-run} \
			$RESOURCE start
		;;

	start)
		assure_module_is_loaded $SEEN_RESOURCES
		for RESOURCE in $DO_RESOURCES ; do
			configure $RESOURCE
		done
		[ -d /var/lock/subsys ] \
		&& $TOUCH /var/lock/subsys/drbd
		connect_and_sync ;;

	stop)
		[ -e $PROC_DRBD ] || { echo "$link stop: nothing to do."; exit 0; }
		FAILED=''
		for RESOURCE in $DO_RESOURCES ; do
			if become_passive $RESOURCE; then
				echo "$link: '$RESOURCE' de-activated"
			else
				FAILED="${FAILED:+$FAILED, }'$RESOURCE[${RET_VAL[1]}]'"
			fi
		done
		if [ -n "$FAILED" ] ; then
			cat <<-_EOF
				$link: $FAILED: resynchronizing, NOT de-activated
				   If you /need/ to stop this, despite of likely data corruption, try one of
				   drbdsetup <device> disconnect # will end the syncer
				   drbdsetup <device> down       # will even unconfigure the device
				   You will have to reconnect/reconfigure of course.
				Module has NOT been unloaded.
				_EOF
			exit -1
		fi
		debug 1 "$RMMOD -s drbd"
		if $RMMOD -s drbd ; then
			[ -f /var/lock/subsys/drbd ] && /bin/rm /var/lock/subsys/drbd
			echo "drbd module has been unloaded"
		else
			if [ "$DO_RESOURCES" == "$SEEN_RESOURCES" ]; then
				die "Can not unload the drbd module."$'\n'
			else
				echo "$link: Module has not been unloaded."
			fi
		fi ;;

	reconnect)
		[ -e $PROC_DRBD ] || { die "$PROC_DRBD not found. Is drbd in kernel?"$'\n'; }
		for RESOURCE in $DO_RESOURCES ; do
			reconnect $RESOURCE
		done ;;
		# QQQ should we? connect_and_sync ;;

	status)
		[ -e $PROC_DRBD ] || { die "$PROC_DRBD not found. Is drbd in kernel?"$'\n'; }
		for RESOURCE in $DO_RESOURCES ; do
		# no short circuit, but list each resource in turn
			connection_status $RESOURCE
			echo "$RESOURCE: $RET_VAL"
			echo -n "${RET_VAL[1]:+${RET_VAL[1]}}"
		done ;;

	*)	print_usage_and_exit ;;

	esac ;;

datadisk)

	[ -e $PROC_DRBD ] || { die "$PROC_DRBD not found. Try drbd start first."$'\n'; }

	case $COMMAND in

	restart)
		export _SCRIPT_RECURSION=yes
		$0 \
			${OPT_CONFIG:+--config=$OPT_CONFIG} \
			${OPT_DUMMY:+--dummy} \
			${OPT_DRY_RUN:+--dry-run} \
			$RESOURCE stop \
		&& \
		$0 \
			${OPT_CONFIG:+--config=$OPT_CONFIG} \
			${OPT_DUMMY:+--dummy} \
			${OPT_DRY_RUN:+--dry-run} \
			$RESOURCE start
		;;

	start)
		for RESOURCE in $DO_RESOURCES ; do
			wait_until_partner_passive $RESOURCE
			become_active $RESOURCE
			echo "$link: '$RESOURCE' activated"
		done ;;

	stop)
		FAILED=''
		for RESOURCE in $DO_RESOURCES ; do
			if become_passive $RESOURCE; then
				echo "$link: '$RESOURCE' de-activated"
			else
				FAILED="${FAILED:+$FAILED, }'$RESOURCE'"
			fi
		done
		if [ -n "$FAILED" ] ; then
			cat <<-_EOF
				$link: $FAILED: resynchronizing, NOT de-activated
				   If you /need/ to stop this, despite of likely data corruption, try one of
				   drbdsetup ${RET_VAL[1]} disconnect # will end the syncer
				   drbdsetup ${RET_VAL[1]} down       # will unconfigure the device
				   You will have to reconnect/reconfigure of course.
				_EOF
			exit -1
		fi ;;

	status)
		for RESOURCE in $DO_RESOURCES ; do
		# no short circuit, but list each resource in turn
			datadisk_status $RESOURCE
			echo "$RESOURCE: $RET_VAL"
		done ;;

	*)	print_usage_and_exit
		;;
	esac ;;

*)	print_usage_and_exit;;

esac

# Style, Comments, Details
###########################

	#l.g.e:
	# My favorite editor is vim. I use tabstops of width 4 for indent,
	# and use indentation for folding of sub sections. For the latter to
	# work reasonably, indent comments, too, and outdent descriptive section
	# headings.  (if you like vim, but don't know folds: help folding)
	#
	# Use global shell array RET_VAL for non $? (success/failure) return
	# values.  Always use array assignment. If you refer to the
	# basename you actually reference the [0] index, so this should be
	# the main return value. Use additional array positions for
	# additional info.
	#
	# The debug levels may not be consistent
	#
	# Use "local" variables in functions. These are visible to
	# subsequently called helper functions.  It makes for less
	# noisy code; but be careful, there are situations, where it is
	# more clean to use function arguments.
	#
	# sometimes outdent returns in the middle of a function
	#
	# Try to use builtin commands or functions and minimal redirection, bash
	# has lots of features you wanted to learn anyways ;)
	#
	# WARNING
	# I hear people say some of the code involved in signal handling is not
	# reentrant. if signals are badly timed, it may yield strange results
	#

	# vim macros
		# only works with :set hidden if file has been changed
		# vim macro for ipell'ing comment blocks
			# :e tmp.ispell
			# dG/^[ 	]*#
			# V/^[ 	]*\([^ 	#]\|$\)
			# kdpkd1G:w!
			# :!ispell %
			# :e!
			# 1GVGdPn

		# vim macro for ipell'ing end commets
			# :e tmp.ispell
			# dG/^[ 	]*[^ 	][^#]\+ # /e
			# d$P:w!
			# :!ispell %
			# :e!
			# 0d$$pj0

# vim: set tw=0 nowrap ts=4 sw=4 ai foldmethod=indent foldcolumn=4 foldignore='' nofoldenable :

